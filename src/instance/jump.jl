#  MIPLearn: Extensible Framework for Learning-Enhanced Mixed-Integer Optimization
#  Copyright (C) 2020-2021, UChicago Argonne, LLC. All rights reserved.
#  Released under the modified BSD license. See COPYING.md for more details.

using JuMP
import JSON

mutable struct JuMPInstance <: Instance
    py::Union{Nothing,PyCall.PyObject}
    model::Union{Nothing,JuMP.Model}
    mps::Union{Nothing,Vector{UInt8}}
    ext::AbstractDict
    samples::Vector{PyCall.PyObject}

    function JuMPInstance(model::JuMP.Model)
        init_miplearn_ext(model)
        instance = new(nothing, model, nothing, model.ext[:miplearn], [])
        py = PyJuMPInstance(instance)
        instance.py = py
        return instance
    end

    function JuMPInstance(mps::Vector{UInt8}, ext::AbstractDict)
        "instance_features" in keys(ext) || error("provided ext is not initialized")
        instance = new(nothing, nothing, mps, ext, [])
        instance.py = PyJuMPInstance(instance)
        return instance
    end
end

function to_model(instance::JuMPInstance)::JuMP.Model
    if instance.model === nothing
        mps_filename = "$(tempname()).mps.gz"
        write(mps_filename, instance.mps)
        instance.model = read_from_file(mps_filename)
        instance.model.ext[:miplearn] = instance.ext
    end
    return instance.model
end

get_instance_features(instance::JuMPInstance) = instance.ext["instance_features"]
get_variable_features(instance::JuMPInstance) = instance.ext["variable_features"]
get_variable_categories(instance::JuMPInstance) = instance.ext["variable_categories"]
get_constraint_features(instance::JuMPInstance) = instance.ext["constraint_features"]
get_constraint_categories(instance::JuMPInstance) = instance.ext["constraint_categories"]
get_samples(instance::JuMPInstance) = instance.samples

function create_sample!(instance::JuMPInstance)
    sample = MemorySample()
    push!(instance.samples, sample)
    return sample
end

function __init_PyJuMPInstance__()
    @pydef mutable struct Class <: miplearn.Instance
        function __init__(self, jl)
            self.jl = jl
        end
        to_model(self) = to_model(self.jl)
        get_instance_features(self) = get_instance_features(self.jl)
        get_variable_features(self) = get_variable_features(self.jl)
        get_variable_categories(self) = get_variable_categories(self.jl)
        get_constraint_features(self,) = get_constraint_features(self.jl)
        get_constraint_categories(self) = get_constraint_categories(self.jl)
        get_samples(self) = get_samples(self.jl)
        create_sample(self) = create_sample!(self.jl)
    end
    copy!(PyJuMPInstance, Class)
end

function save(filename::AbstractString, instance::JuMPInstance)::Nothing
    # Convert JuMP model to MPS
    mps_filename = "$(tempname()).mps.gz"
    model = instance.py.to_model()
    write_to_file(model, mps_filename)
    mps = read(mps_filename)

    # Generate HDF5
    h5 = Hdf5Sample(filename, mode="w")
    h5.put_scalar("miplearn_version", "0002")
    h5.put_bytes("mps", mps)
    h5.put_scalar("jump_ext", JSON.json(model.ext[:miplearn]))
    return
end

function _check_miplearn_version(h5)
    v = h5.get_scalar("miplearn_version")
    v == "0002" || error(
        "The file you are trying to load has been generated by " *
        "MIPLearn $(v) and you are currently running MIPLearn 0002 " *
        "Reading files generated by different versions of MIPLearn is " *
        "not currently supported."
    )
end

function load_instance(filename::AbstractString)::JuMPInstance
    h5 = Hdf5Sample(filename)
    _check_miplearn_version(h5)
    mps = h5.get_bytes("mps")
    ext = h5.get_scalar("jump_ext")
    instance = JuMPInstance(Vector{UInt8}(mps), JSON.parse(ext))
    return instance
end

export JuMPInstance, save, load_instance
