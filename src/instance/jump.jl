#  MIPLearn: Extensible Framework for Learning-Enhanced Mixed-Integer Optimization
#  Copyright (C) 2020-2021, UChicago Argonne, LLC. All rights reserved.
#  Released under the modified BSD license. See COPYING.md for more details.

using JuMP
using JLD2

mutable struct JuMPInstance <: Instance
    py::Union{Nothing,PyCall.PyObject}
    model::Union{Nothing,JuMP.Model}
    mps::Union{Nothing,Vector{UInt8}}
    ext::AbstractDict
    samples::Vector{PyCall.PyObject}

    function JuMPInstance(model::JuMP.Model)
        init_miplearn_ext(model)
        instance = new(nothing, model, nothing, model.ext[:miplearn], [])
        py = PyJuMPInstance(instance)
        instance.py = py
        return instance
    end

    function JuMPInstance(mps::Vector{UInt8}, ext::AbstractDict)
        "instance_features" in keys(ext) || error("provided ext is not initialized")
        instance = new(nothing, nothing, mps, ext, [])
        instance.py = PyJuMPInstance(instance)
        return instance
    end
end

function to_model(instance::JuMPInstance)::JuMP.Model
    if instance.model === nothing
        mps_filename = "$(tempname()).mps.gz"
        write(mps_filename, instance.mps)
        instance.model = read_from_file(mps_filename)
        instance.model.ext[:miplearn] = instance.ext
    end
    return instance.model
end

get_instance_features(instance::JuMPInstance) = instance.ext["instance_features"]
get_variable_features(instance::JuMPInstance) = instance.ext["variable_features"]
get_variable_categories(instance::JuMPInstance) = instance.ext["variable_categories"]
get_constraint_features(instance::JuMPInstance) = instance.ext["constraint_features"]
get_constraint_categories(instance::JuMPInstance) = instance.ext["constraint_categories"]
get_samples(instance::JuMPInstance) = instance.samples

function push_sample!(instance::JuMPInstance, sample::PyCall.PyObject)
    push!(instance.samples, sample)
end

function __init_PyJuMPInstance__()
    @pydef mutable struct Class <: miplearn.Instance
        function __init__(self, jl)
            self.jl = jl
        end
        to_model(self) = to_model(self.jl)
        get_instance_features(self) = get_instance_features(self.jl)
        get_variable_features(self) = get_variable_features(self.jl)
        get_variable_categories(self) = get_variable_categories(self.jl)
        get_constraint_features(self,) = get_constraint_features(self.jl)
        get_constraint_categories(self) = get_constraint_categories(self.jl)
        get_samples(self) = get_samples(self.jl)
        push_sample(self, sample) = push_sample!(self.jl, sample)
    end
    copy!(PyJuMPInstance, Class)
end

function save(filename::AbstractString, instance::JuMPInstance)::Nothing
    # Convert JuMP model to MPS
    mps_filename = "$(tempname()).mps.gz"
    model = instance.py.to_model()
    write_to_file(model, mps_filename)
    mps = read(mps_filename)

    # Pickle instance.py.samples. Ideally, we would use dumps and loads, but this
    # causes some issues with PyCall, probably due to automatic type conversions.
    samples_filename = tempname()
    miplearn.write_pickle_gz(instance.samples, samples_filename)
    samples = read(samples_filename)

    # Generate JLD2 file
    jldsave(
        filename;
        miplearn_version="0.2",
        mps=mps,
        ext=model.ext[:miplearn],
        samples=samples,
    )
    return
end

function _check_miplearn_version(file)
    v = file["miplearn_version"]
    v == "0.2" || error(
        "The file you are trying to load has been generated by " *
        "MIPLearn $(v) and you are currently running MIPLearn 0.2. " *
        "Reading files generated by different versions of MIPLearn is " *
        "not currently supported."
    )
end

function load_instance(filename::AbstractString)::JuMPInstance
    jldopen(filename, "r") do file
        _check_miplearn_version(file)
        instance = JuMPInstance(file["mps"], file["ext"])
        samples_filename = tempname()
        write(samples_filename, file["samples"])
        @time instance.samples = miplearn.read_pickle_gz(samples_filename)
        return instance
    end
end

export JuMPInstance, save, load_instance
